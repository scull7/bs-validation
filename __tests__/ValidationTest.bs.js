// Generated by BUCKLESCRIPT VERSION 4.0.3, PLEASE EDIT WITH CARE
'use strict';

var Jest = require("@glennsl/bs-jest/src/jest.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Validation = require("../src/Validation.bs.js");

var concat = Belt_Array.concat;

var FoldableArray = /* module */[/* concat */concat];

var V = Validation.Make_validation(FoldableArray);

describe("Validation", (function () {
        describe("Functor", (function () {
                Jest.test("map should equal application", (function () {
                        var f = function (x) {
                          return x + 1 | 0;
                        };
                        var expected = Curry._1(V[/* make */10], 2);
                        var actual = Curry._2(V[/* map */0], f, Curry._1(V[/* make */10], 1));
                        return Jest.Expect[/* toEqual */12](expected, Jest.Expect[/* expect */0](actual));
                      }));
                return Jest.test("map should not modify a failure", (function () {
                              var f = function (x) {
                                return x + 1 | 0;
                              };
                              var expected = /* Failure */Block.__(0, [/* array */[1]]);
                              var actual = Curry._2(V[/* map */0], f, /* Failure */Block.__(0, [/* array */[1]]));
                              return Jest.Expect[/* toEqual */12](expected, Jest.Expect[/* expect */0](actual));
                            }));
              }));
        describe("Applicative", (function () {
                Jest.test("make (of)", (function () {
                        var actual = Curry._1(V[/* make */10], 1);
                        return Jest.Expect[/* toEqual */12](/* Success */Block.__(1, [1]), Jest.Expect[/* expect */0](actual));
                      }));
                Jest.test("Success#apply", (function () {
                        var f = function (x, y) {
                          return x + y | 0;
                        };
                        var actual = Curry._2(V[/* apply */1], /* Success */Block.__(1, [4]), Curry._2(V[/* apply */1], /* Success */Block.__(1, [3]), Curry._1(V[/* make */10], f)));
                        return Jest.Expect[/* toEqual */12](/* Success */Block.__(1, [7]), Jest.Expect[/* expect */0](actual));
                      }));
                Jest.test("Success/Failure#apply", (function () {
                        var f = function (x, y) {
                          return x + y | 0;
                        };
                        var expected = /* Failure */Block.__(0, [/* array */[7]]);
                        var actual = Curry._2(V[/* apply */1], /* Failure */Block.__(0, [/* array */[7]]), Curry._2(V[/* apply */1], /* Success */Block.__(1, [3]), Curry._1(V[/* make */10], f)));
                        return Jest.Expect[/* toEqual */12](expected, Jest.Expect[/* expect */0](actual));
                      }));
                return Jest.test("Failure#apply", (function () {
                              var f = function (x, y) {
                                return x + y | 0;
                              };
                              var expected = /* Failure */Block.__(0, [/* array */[
                                    7,
                                    8
                                  ]]);
                              var actual = Curry._2(V[/* apply */1], /* Failure */Block.__(0, [/* array */[8]]), Curry._2(V[/* apply */1], /* Failure */Block.__(0, [/* array */[7]]), Curry._1(V[/* make */10], f)));
                              return Jest.Expect[/* toEqual */12](expected, Jest.Expect[/* expect */0](actual));
                            }));
              }));
        describe("Folds", (function () {
                return Jest.test("mapFailure should map over a failure", (function () {
                              var f = function (param) {
                                if (param.length !== 1) {
                                  return Pervasives.failwith("unexpected_input");
                                } else {
                                  var x = param[0];
                                  return /* array */[x + 10 | 0];
                                }
                              };
                              var expected = /* Failure */Block.__(0, [/* array */[11]]);
                              var actual = Curry._2(V[/* mapFailure */9], f, /* Failure */Block.__(0, [/* array */[1]]));
                              return Jest.Expect[/* toEqual */12](expected, Jest.Expect[/* expect */0](actual));
                            }));
              }));
        return /* () */0;
      }));

exports.FoldableArray = FoldableArray;
exports.V = V;
/* V Not a pure module */
